import { Shape, Rectangle, Circle, CustomPath, Hole } from './types'

export function exportToSVG(shapes: Shape[], width: number = 800, height: number = 600): string {
  if (shapes.length === 0) {
    throw new Error('No shapes to export')
  }

  // Calculate bounding box for all shapes
  const bounds = calculateBounds(shapes)
  const padding = 10

  const viewBoxWidth = bounds.maxX - bounds.minX + padding * 2
  const viewBoxHeight = bounds.maxY - bounds.minY + padding * 2
  const viewBoxX = bounds.minX - padding
  const viewBoxY = bounds.minY - padding

  let svgContent = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n`
  svgContent += `<svg xmlns="http://www.w3.org/2000/svg" `
  svgContent += `width="${width}" height="${height}" `
  svgContent += `viewBox="${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}">\n`
  svgContent += `  <title>Laser Cutting Design</title>\n`
  svgContent += `  <desc>Generated by Spartan Design</desc>\n`
  svgContent += `  <g id="design">\n`

  // Convert each shape to SVG
  shapes.forEach(shape => {
    const shapeSVG = shapeToSVG(shape)
    if (shapeSVG) {
      svgContent += `    ${shapeSVG}\n`

      // Add holes if present
      if (shape.holes && shape.holes.length > 0) {
        shape.holes.forEach(hole => {
          const holeSVG = holeToSVG(hole, shape.position)
          if (holeSVG) {
            svgContent += `    ${holeSVG}\n`
          }
        })
      }
    }
  })

  svgContent += `  </g>\n`
  svgContent += `</svg>`

  return svgContent
}

function shapeToSVG(shape: Shape): string {
  const strokeColor = shape.color || '#000000'
  const strokeWidth = 0.5 // Thin line for laser cutting

  switch (shape.type) {
    case 'rectangle': {
      const rect = shape as Rectangle
      return `<rect x="${rect.position.x - rect.width / 2}" y="${rect.position.y - rect.height / 2}" width="${rect.width}" height="${rect.height}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    case 'circle': {
      const circle = shape as Circle
      return `<circle cx="${circle.position.x}" cy="${circle.position.y}" r="${circle.radius}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    case 'custom': {
      const custom = shape as CustomPath
      if (custom.points.length < 2) return ''

      let pathData = `M ${custom.points[0].x} ${custom.points[0].y}`
      for (let i = 1; i < custom.points.length; i++) {
        pathData += ` L ${custom.points[i].x} ${custom.points[i].y}`
      }
      pathData += ' Z' // Close the path

      return `<path d="${pathData}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    default:
      return ''
  }
}

function holeToSVG(hole: Hole, parentPosition: { x: number; y: number }): string {
  const strokeColor = '#000000'
  const strokeWidth = 0.5

  // Calculate absolute position (hole position is relative to parent)
  const absX = parentPosition.x + hole.position.x
  const absY = parentPosition.y + hole.position.y

  if (hole.type === 'rectangle' && hole.width && hole.height) {
    return `<rect x="${absX - hole.width / 2}" y="${absY - hole.height / 2}" width="${hole.width}" height="${hole.height}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="2,2" />`
  } else if (hole.type === 'circle' && hole.radius) {
    return `<circle cx="${absX}" cy="${absY}" r="${hole.radius}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="2,2" />`
  }

  return ''
}

function calculateBounds(shapes: Shape[]) {
  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  shapes.forEach(shape => {
    switch (shape.type) {
      case 'rectangle': {
        const rect = shape as Rectangle
        const halfWidth = rect.width / 2
        const halfHeight = rect.height / 2
        minX = Math.min(minX, rect.position.x - halfWidth)
        minY = Math.min(minY, rect.position.y - halfHeight)
        maxX = Math.max(maxX, rect.position.x + halfWidth)
        maxY = Math.max(maxY, rect.position.y + halfHeight)
        break
      }

      case 'circle': {
        const circle = shape as Circle
        minX = Math.min(minX, circle.position.x - circle.radius)
        minY = Math.min(minY, circle.position.y - circle.radius)
        maxX = Math.max(maxX, circle.position.x + circle.radius)
        maxY = Math.max(maxY, circle.position.y + circle.radius)
        break
      }

      case 'custom': {
        const custom = shape as CustomPath
        custom.points.forEach(point => {
          minX = Math.min(minX, point.x)
          minY = Math.min(minY, point.y)
          maxX = Math.max(maxX, point.x)
          maxY = Math.max(maxY, point.y)
        })
        break
      }
    }
  })

  return { minX, minY, maxX, maxY }
}

export function downloadSVG(svgContent: string, filename: string = 'design.svg') {
  const blob = new Blob([svgContent], { type: 'image/svg+xml' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}
