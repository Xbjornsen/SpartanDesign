import { Shape, Rectangle, Circle, CustomPath, Hole, Bend } from './types'

export function exportToSVG(shapes: Shape[], width: number = 800, height: number = 600): string {
  if (shapes.length === 0) {
    throw new Error('No shapes to export')
  }

  // Calculate bounding box for all shapes
  const bounds = calculateBounds(shapes)
  const padding = 10

  const viewBoxWidth = bounds.maxX - bounds.minX + padding * 2
  const viewBoxHeight = bounds.maxY - bounds.minY + padding * 2
  const viewBoxX = bounds.minX - padding
  const viewBoxY = bounds.minY - padding

  let svgContent = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n`
  svgContent += `<svg xmlns="http://www.w3.org/2000/svg" `
  svgContent += `width="${width}" height="${height}" `
  svgContent += `viewBox="${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}">\n`
  svgContent += `  <title>Laser Cutting Design</title>\n`
  svgContent += `  <desc>Generated by Spartan Design</desc>\n`
  svgContent += `  <g id="design">\n`

  // Convert each shape to SVG
  shapes.forEach(shape => {
    const shapeSVG = shapeToSVG(shape)
    if (shapeSVG) {
      svgContent += `    ${shapeSVG}\n`

      // Add holes if present
      if (shape.holes && shape.holes.length > 0) {
        shape.holes.forEach(hole => {
          const holeSVG = holeToSVG(hole, shape.position)
          if (holeSVG) {
            svgContent += `    ${holeSVG}\n`
          }
        })
      }

      // Add bend lines if present
      if (shape.bends && shape.bends.length > 0) {
        shape.bends.forEach(bend => {
          const bendSVG = bendToSVG(bend, shape)
          if (bendSVG) {
            svgContent += `    ${bendSVG}\n`
          }
        })
      }
    }
  })

  svgContent += `  </g>\n`
  svgContent += `</svg>`

  return svgContent
}

function shapeToSVG(shape: Shape): string {
  const strokeColor = shape.color || '#000000'
  const strokeWidth = 0.5 // Thin line for laser cutting

  switch (shape.type) {
    case 'rectangle': {
      const rect = shape as Rectangle
      return `<rect x="${rect.position.x - rect.width / 2}" y="${rect.position.y - rect.height / 2}" width="${rect.width}" height="${rect.height}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    case 'circle': {
      const circle = shape as Circle
      return `<circle cx="${circle.position.x}" cy="${circle.position.y}" r="${circle.radius}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    case 'custom': {
      const custom = shape as CustomPath
      if (custom.points.length < 2) return ''

      let pathData = `M ${custom.points[0].x} ${custom.points[0].y}`
      for (let i = 1; i < custom.points.length; i++) {
        pathData += ` L ${custom.points[i].x} ${custom.points[i].y}`
      }
      pathData += ' Z' // Close the path

      return `<path d="${pathData}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" />`
    }

    default:
      return ''
  }
}

function holeToSVG(hole: Hole, parentPosition: { x: number; y: number }): string {
  const strokeColor = '#000000'
  const strokeWidth = 0.5

  // Calculate absolute position (hole position is relative to parent)
  const absX = parentPosition.x + hole.position.x
  const absY = parentPosition.y + hole.position.y

  if (hole.type === 'rectangle' && hole.width && hole.height) {
    return `<rect x="${absX - hole.width / 2}" y="${absY - hole.height / 2}" width="${hole.width}" height="${hole.height}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="2,2" />`
  } else if (hole.type === 'circle' && hole.radius) {
    return `<circle cx="${absX}" cy="${absY}" r="${hole.radius}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="2,2" />`
  }

  return ''
}

function bendToSVG(bend: Bend, shape: Shape): string {
  if (shape.type !== 'rectangle') return ''

  const rect = shape as Rectangle
  const bendColor = '#ff6600' // Orange color for bend lines
  const strokeWidth = 1

  // Calculate bend line position
  let x1, y1, x2, y2
  if (bend.orientation === 'horizontal') {
    // Horizontal bend line (left to right)
    const yPos = shape.position.y - rect.height / 2 + bend.position
    x1 = shape.position.x - rect.width / 2
    y1 = yPos
    x2 = shape.position.x + rect.width / 2
    y2 = yPos
  } else {
    // Vertical bend line (top to bottom)
    const xPos = shape.position.x - rect.width / 2 + bend.position
    x1 = xPos
    y1 = shape.position.y - rect.height / 2
    x2 = xPos
    y2 = shape.position.y + rect.height / 2
  }

  // Calculate midpoint for text label
  const midX = (x1 + x2) / 2
  const midY = (y1 + y2) / 2

  // Create SVG group with bend line and annotation
  let svg = `<g id="bend-${bend.id}">\n`
  svg += `      <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${bendColor}" stroke-width="${strokeWidth}" stroke-dasharray="5,5" />\n`
  svg += `      <text x="${midX}" y="${midY - 2}" text-anchor="middle" font-size="8" fill="${bendColor}" font-weight="bold">`
  svg += `BEND ${bend.angle}° ${bend.direction.toUpperCase()} | R${bend.radius}mm`
  svg += `</text>\n`
  svg += `    </g>`

  return svg
}

function calculateBounds(shapes: Shape[]) {
  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity

  shapes.forEach(shape => {
    switch (shape.type) {
      case 'rectangle': {
        const rect = shape as Rectangle
        const halfWidth = rect.width / 2
        const halfHeight = rect.height / 2
        minX = Math.min(minX, rect.position.x - halfWidth)
        minY = Math.min(minY, rect.position.y - halfHeight)
        maxX = Math.max(maxX, rect.position.x + halfWidth)
        maxY = Math.max(maxY, rect.position.y + halfHeight)
        break
      }

      case 'circle': {
        const circle = shape as Circle
        minX = Math.min(minX, circle.position.x - circle.radius)
        minY = Math.min(minY, circle.position.y - circle.radius)
        maxX = Math.max(maxX, circle.position.x + circle.radius)
        maxY = Math.max(maxY, circle.position.y + circle.radius)
        break
      }

      case 'custom': {
        const custom = shape as CustomPath
        custom.points.forEach(point => {
          minX = Math.min(minX, point.x)
          minY = Math.min(minY, point.y)
          maxX = Math.max(maxX, point.x)
          maxY = Math.max(maxY, point.y)
        })
        break
      }
    }
  })

  return { minX, minY, maxX, maxY }
}

export function downloadSVG(svgContent: string, filename: string = 'design.svg') {
  const blob = new Blob([svgContent], { type: 'image/svg+xml' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

// Export bend instructions as JSON
export function exportBendInstructions(shapes: Shape[]): string {
  const bendInstructions: any[] = []

  shapes.forEach((shape, shapeIndex) => {
    if (shape.bends && shape.bends.length > 0 && shape.type === 'rectangle') {
      const rect = shape as Rectangle

      shape.bends.forEach((bend, bendIndex) => {
        bendInstructions.push({
          shapeId: shape.id,
          shapeIndex: shapeIndex + 1,
          bendNumber: bendIndex + 1,
          orientation: bend.orientation,
          position: {
            value: bend.position,
            unit: 'mm',
            description: bend.orientation === 'horizontal'
              ? `${bend.position}mm from bottom edge`
              : `${bend.position}mm from left edge`
          },
          angle: {
            value: bend.angle,
            unit: 'degrees'
          },
          direction: bend.direction,
          bendRadius: {
            value: bend.radius,
            unit: 'mm'
          },
          sheetDimensions: {
            width: rect.width,
            height: rect.height,
            unit: 'mm'
          }
        })
      })
    }
  })

  const exportData = {
    exportDate: new Date().toISOString(),
    generator: 'Spartan Design',
    totalBends: bendInstructions.length,
    bends: bendInstructions
  }

  return JSON.stringify(exportData, null, 2)
}

export function downloadBendInstructions(jsonContent: string, filename: string = 'bend-instructions.json') {
  const blob = new Blob([jsonContent], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

// Export bend instructions as human-readable plain text
export function exportBendInstructionsText(shapes: Shape[]): string {
  let textContent = '========================================\n'
  textContent += '   SHEET METAL BENDING INSTRUCTIONS\n'
  textContent += '========================================\n\n'
  textContent += `Generated: ${new Date().toLocaleString()}\n`
  textContent += `Source: Spartan Design Platform\n\n`

  let totalBends = 0
  const bendsPerShape: { shape: Shape; bends: any[] }[] = []

  // Collect all bends
  shapes.forEach((shape, shapeIndex) => {
    if (shape.bends && shape.bends.length > 0 && shape.type === 'rectangle') {
      totalBends += shape.bends.length
      bendsPerShape.push({ shape, bends: shape.bends })
    }
  })

  if (totalBends === 0) {
    textContent += 'No bends required for this design.\n'
    return textContent
  }

  textContent += `TOTAL BENDS REQUIRED: ${totalBends}\n\n`
  textContent += '========================================\n\n'

  // List each shape with bends
  bendsPerShape.forEach(({ shape, bends }, shapeIndex) => {
    const rect = shape as Rectangle

    textContent += `PART ${shapeIndex + 1}: Rectangle (${rect.width}mm × ${rect.height}mm)\n`
    textContent += `${'='.repeat(50)}\n\n`

    textContent += `Sheet Dimensions:\n`
    textContent += `  - Width:  ${rect.width.toFixed(2)} mm\n`
    textContent += `  - Height: ${rect.height.toFixed(2)} mm\n\n`

    bends.forEach((bend, bendIndex) => {
      const bendNumber = bendIndex + 1

      textContent += `BEND #${bendNumber}:\n`
      textContent += `${'-'.repeat(40)}\n`

      // Position description
      if (bend.orientation === 'horizontal') {
        textContent += `  Location: HORIZONTAL bend line\n`
        textContent += `  Position: ${bend.position.toFixed(2)} mm from BOTTOM edge\n`
      } else {
        textContent += `  Location: VERTICAL bend line\n`
        textContent += `  Position: ${bend.position.toFixed(2)} mm from LEFT edge\n`
      }

      // Bend specifications
      textContent += `  Bend Angle: ${bend.angle}°\n`
      textContent += `  Direction: ${bend.direction.toUpperCase()} (${bend.direction === 'up' ? '+Z' : '-Z'})\n`
      textContent += `  Inside Radius: ${bend.radius.toFixed(2)} mm\n\n`

      // Step-by-step instructions
      textContent += `  STEPS:\n`
      textContent += `  1. Mark bend line at ${bend.position.toFixed(2)}mm from ${bend.orientation === 'horizontal' ? 'bottom' : 'left'} edge\n`
      textContent += `  2. Set press brake to ${bend.angle}° angle\n`
      textContent += `  3. Use ${bend.radius.toFixed(2)}mm radius die\n`
      textContent += `  4. Position sheet with bend line aligned to die\n`
      textContent += `  5. Bend ${bend.direction === 'up' ? 'upward' : 'downward'} to ${bend.angle}°\n`
      textContent += `  6. Verify angle with protractor/gauge\n\n`
    })

    textContent += '\n'
  })

  textContent += '========================================\n'
  textContent += 'IMPORTANT NOTES:\n'
  textContent += '========================================\n'
  textContent += '- Bend lines are marked on the SVG file with orange dashed lines\n'
  textContent += '- All measurements are in millimeters (mm)\n'
  textContent += '- Complete bends in the order listed above\n'
  textContent += '- Verify all angles after bending\n'
  textContent += '- Check for material springback and adjust if needed\n'
  textContent += '- Ensure proper die clearance for material thickness\n\n'

  textContent += '========================================\n'
  textContent += 'END OF BEND INSTRUCTIONS\n'
  textContent += '========================================\n'

  return textContent
}
